import pyotp
from fastapi import HTTPException, Depends, status, APIRouter
from sqlalchemy.orm import Session

from app.config import settings
from app.database import get_db
from app.models.users import Users
from app.schemas.users import User
from app.utils.helper_functions import generate_qr

router = APIRouter()


@router.get("/otp", status_code=status.HTTP_200_OK)
async def generate_qr_code(phone_number: str, db: Session = Depends(get_db)):
        """
        This route generates a QR code for the user based on the phone number, the QR code generated is in base64 format and needs to be decoded before displaying it to the user.
        The user can scan the QR code using any authenticator app like Google Authenticator, Microsoft Authenticator, etc.

        :param phone_number:  Phone number of the user \n
        :param db:  Database session \n

        :return:  Base64 encoded QR code

        :raises HTTPException(500):  In case of unexpected errors
        """
        try:
                # Step 1: Fetch the user from the database based on name and phone number
                user = Users.get_user_by_phone_number(db, phone_number)

                # Step 2: Use candidate's OTP secret or fallback to universal secret
                otp_secret = str(user.otp_secret) if user else settings.SECRET_KEY

                # Step 3: Generate OTP using PyOTP TOTP with a time interval of 60 seconds
                totp = pyotp.TOTP(otp_secret)
                data = totp.provisioning_uri(phone_number, issuer_name="mechXsteam")
                base64_qr_code = generate_qr(data)

                # Step 4: Return the generated OTP code
                return base64_qr_code

        # Step 5: Raise HTTPException in case of unexpected errors
        except Exception as error:
                raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(error)) from error


@router.post("/register-candidate", status_code=status.HTTP_200_OK)
async def register_user(user: User, otp_code: int, db: Session = Depends(get_db)):
        """
        This route registers a new user in the database, the user needs to provide the OTP code generated by the authenticator app along with the necessary
         user details specified in the schema to complete the registration process.
        :param user:  User details (name**, phone number**, email) \n
        :param otp_code:  OTP code generated by the authenticator app \n
        :param db:  Database session \n

        :return:  Success message along with the access token

        :raises HTTPException(400):  In the case of user already exists
        :raises HTTPException(401):  In the case of invalid OTP code
        :raises HTTPException(500):  In case of unexpected errors
        """
        try:
                # Step 1: Check if the user already exists in the database
                existing_user = Users.get_user_by_phone_number(db, user.phone_number)

                # Step 2: If the user already exists, raise HTTPException with status code 400
                if existing_user:
                        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="User already exists")

                # Step 3: For the first time, we will use the secret key specified in the .env file to generate and verify the OTP
                otp_secret = str(settings.SECRET_KEY)
                totp = pyotp.TOTP(otp_secret)

                # Step 3.1: Verify the OTP code provided by the user, raise HTTPException with status code 401 if the OTP code is invalid
                if not totp.verify(str(otp_code)):
                        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid OTP code")

                # Step 4: If the OTP code is valid, create a new user in the database and generate an access token for the user
                new_user = {"name": user.name, "phone_number": user.phone_number, "email": user.email, "otp_secret": pyotp.random_base32()}
                user = Users.create_user(db, **new_user)

                # Step 5: Generate an access token for the user
                access_token = Users.generate_access_token(db, user.phone_number)

                # Step 6: Return the success message along with the access token
                return {"message": "User created successfully", "token_type": "Bearer", "access_token": access_token}

        # Step 7: Handle the exceptions
        except HTTPException as error:
                raise error

        except Exception as error:
                raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(error)) from error


@router.post("/login", status_code=status.HTTP_200_OK)
async def login(phone_number: str, otp_code: int, db: Session = Depends(get_db)):
        """
        This route logs in the user, the user needs to provide the OTP code generated by the authenticator app along with the phone number to complete the login process.

        :param phone_number:  Phone number of the user \n
        :param otp_code:  OTP code generated by the authenticator app \n
        :param db:  Database session \n

        :return:  Success message along with the access token

        :raises HTTPException(401):  In the case of invalid OTP code
        :raises HTTPException(500):  In case of unexpected errors
        """
        try:
                # Step 1: Fetch the user from the database based on name and phone number
                user = Users.get_user_by_phone_number(db, phone_number)

                # Step 2: Use candidate's OTP secret or fallback to universal secret
                otp_secret = str(user.otp_secret)

                # Step 3: Generate OTP using PyOTP TOTP with a time interval of 60 seconds
                totp = pyotp.TOTP(otp_secret)

                # Step 4: Verify the OTP code provided by the user, raise HTTPException with status code 401 if the OTP code is invalid
                if not totp.verify(str(otp_code)):
                        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid OTP code")

                # Step 5: Generate an access token for the user
                access_token = Users.generate_access_token(db, phone_number)

                # Step 6: Return the success message along with the access token
                return {"message": "User logged in successfully", "token_type": "Bearer", "access_token": access_token}

        # Step 7: Handle the exceptions
        except HTTPException as error:
                raise error

        except Exception as error:
                raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(error)) from error
